{
    parserClass = "org.intellij.fsharp.lang.parser.FSharpParser"
    parserUtilClass = "org.intellij.fsharp.lang.parser.FSharpParserUtil"

    implements = "org.intellij.fsharp.lang.parser.psi.FSharpCompositeElement"
    extends = "org.intellij.fsharp.lang.parser.psi.impl.FSharpCompositeElementImpl"

    elementTypeHolderClass = "org.intellij.fsharp.lang.parser.psi.FSharpTypes"
    elementTypePrefix = "FS_"
    elementTypeClass = "org.intellij.fsharp.lang.parser.psi.FSharpCompositeElementType"
    tokenTypeClass = "org.intellij.fsharp.lang.parser.psi.FSharpTokenType"

    psiClassPrefix = "FSharp"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.intellij.fsharp.lang.parser.psi"
    psiImplPackage = "org.intellij.fsharp.lang.parser.psi.impl"
    psiImplUtilClass = "org.intellij.fsharp.lang.parser.psi.FSharpPsiImplUtil"

    generateTokenAccessors = true

    tokens = [
             letter = 'regexp:[A-Za-z]'
             space = 'regexp:\s+'
             comment = 'regexp://.*'
             number = 'regexp:\d+(\.\d*)?'
             op_Nil = '[]'
             op_ColonColon = '::'
             op_Addition = '+'
             op_Subtraction = '-'
             op_Multiply = '*'

        ]
    extends("*.pat") = pat
}

root ::= rule //debugging purposes

//A.2.1 Expressions
implementation-file ::= (namespace-decl-group+ named-module)+ | named-module //| anon-module
namespace-decl-group ::= namespace global? long_ident module-elems
named-module ::= module long_ident module-elems
anon-module ::= module-elems
long_ident ::= (ident '.')* ident
module-elems ::=
   module-func-or-val-defn
module-func-or-val-defn ::=
   attr? let function-defn
attr ::=
ident ::= letter (letter | number)* //todo : add proper ident
function-defn ::= inline? access? ident-or-op typar-defns? args-pats ret-type? '=' expr

//Patterns
rule ::= pat pattern-guard? '->' expr
pattern-guard ::= when expr
pat ::=
    | const_pat          //constant pattern
    | named_pat         //named pattern
    | wildcard_pat      //wildcard pattern
    | as_pat            //"as" pattern
    | disj_pat          //disjunctive pattern
    | conj_pat          //conjunctive pattern
    | cons_pat          //"cons" pattern
    | tuple_pat         //tuple pattern
    | paren_pat         //parenthesized pattern
    | list_pat          //list pattern
    //| array-pat                     //array pattern
    //| record-pat                    //record pattern
//    | ':?' atom-pat                 //dynamic type test pattern
//    | ':?' atom-pat as ident        //dynamic type test pattern
//    | null                          //null-test pattern
    //| attr pat                      //pattern with attributes
const_pat ::= cons
named_pat ::= long_ident //pat-param? pat?
wildcard_pat ::= "_"
as_pat ::= pat as ident
disj_pat ::= pat "|" pat
conj_pat ::= pat "&" pat
cons_pat ::= pat "::" pat
tuple_pat ::= pat ":" pat
paren_pat ::= '(' pat ')'
list_pat ::= "[]" //| ('[' (pat ';')* pat ']')

pat-param ::=

args-pats ::= atom-pat+
atom-pat ::=

expr ::= number+
cons ::= number+

typar-defns ::= attr? typar

typar ::=
    '_' //anonymous variable type
    | "'" ident //type variable
    | '^' ident //static variable



ident-or-op ::= ident | '(' op_name ')' | '(*)'

op_name ::= symbolic-op | range-op-name | active-pattern-op-name

symbolic-op ::= op_Nil | op_ColonColon | op_Addition | op_Subtraction | op_Multiply //todo: remaining operators

access ::= private | internal | public


