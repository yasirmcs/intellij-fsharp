{
    parserClass = "org.intellij.fsharp.lang.parser.FSharpParser"
    parserUtilClass = "org.intellij.fsharp.lang.parser.FSharpParserUtil"

    implements = "org.intellij.fsharp.lang.parser.psi.FSharpCompositeElement"
    extends = "org.intellij.fsharp.lang.parser.psi.impl.FSharpCompositeElementImpl"

    elementTypeHolderClass = "org.intellij.fsharp.lang.parser.psi.FSharpTypes"
    elementTypePrefix = "FS_"
    elementTypeClass = "org.intellij.fsharp.lang.parser.psi.FSharpCompositeElementType"
    tokenTypeClass = "org.intellij.fsharp.lang.parser.psi.FSharpTokenType"

    psiClassPrefix = "FSharp"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.intellij.fsharp.lang.parser.psi"
    psiImplPackage = "org.intellij.fsharp.lang.parser.psi.impl"
    psiImplUtilClass = "org.intellij.fsharp.lang.parser.psi.FSharpPsiImplUtil"

    generateTokenAccessors = true

    tokens = [
             letter = 'regexp:[A-Za-z]'
             space = 'regexp:\s+'
             comment = 'regexp://.*'
             number = 'regexp:\d+(\.\d*)?'
             op_Nil = '[]'
             op_ColonColon = '::'
             op_Addition = '+'
             op_Subtraction = '-'
             op_Multiply = '*'

        ]
    extends("*.pat") = pat
    extends("*.parampat") = parampat
}

root ::= rule //debugging purposes

//A.2.1 Expressions
implementation-file ::= (namespace-decl-group+ named-module)+ | named-module //| anon-module
namespace-decl-group ::= namespace global? long_ident module-elems
named-module ::= module long_ident module-elems
anon-module ::= module-elems
long_ident ::= (ident '.')* ident
module-elems ::=
   module-func-or-val-defn
module-func-or-val-defn ::=
   attr? let function-defn
attr ::=
ident ::= letter (letter | number)* //todo : add proper ident
function-defn ::= inline? access? ident-or-op typar-defns? args-pats ret-type? '=' expr

//Pattern matching
rule ::= pat pattern-guard? '->' expr
pattern-guard ::= when expr
pat ::=
    | const_pat         //constant pattern
    | named_pat         //named pattern
    | wildcard_pat      //wildcard pattern
    | as_pat            //"as" pattern
    | disj_pat          //disjunctive pattern
    | conj_pat          //conjunctive pattern
    | cons_pat          //"cons" pattern
    | constr_pat        //constrain pattern
    | tuple_pat         //tuple pattern
    | paren_pat         //parenthesized pattern
    | list_pat          //list pattern
    | array_pat         //array pattern
    | record_pat        //record pattern
    | atom_pat          //dynamic type test pattern
    | atomid_pat        //dynamic type test pattern
    | null_pat          //null-test pattern
    | attr_pat          //pattern with attributes
const_pat ::= cons
named_pat ::= long_ident pat-param? pat?
wildcard_pat ::= "_"
as_pat ::= pat as ident
disj_pat ::= pat "|" pat
conj_pat ::= pat "&" pat
cons_pat ::= pat "::" pat
constr_pat ::= pat ":" pat
tuple_pat ::= ('(' pat',')+ pat')'
paren_pat ::= '(' pat ')'
list_pat ::= "[]" | ('[' (pat ';')* pat ']')
array_pat ::= "[| |]" | ("[|" (pat ';')* pat "|]")
record_pat ::= "{"( field_pat ';')* field_pat "}"
atom_pat ::= ":?" atom_type
atomid_pat ::= ":?" atom_type as ident
null_pat ::= null
attr_pat ::= todo
atom_type ::= const_pat | long_ident | list_pat | record_pat | array_pat | paren_pat | null_pat | wildcard_pat
field_pat ::= long_ident '=' pat

parampat ::= //pattern parameters
    | cons_parampat
    | named_parampat
    | brack_parampat
    | tuple_parampat
    | constr_parampat
    | quote_parampat
    | dquote_parampat
    | null_parampat
cons_parampat ::= cons
named_parampat ::= long_ident parampat?
brack_parampat ::= "[" (parampat ";")* parampat "]"
tuple_parampat ::= "(" (parampat "'")* parampat ")"


args-pats ::= atom-pat+
expr ::= number+
cons ::= number+

typar-defns ::= attr? typar

typar ::=
    '_' //anonymous variable type
    | "'" ident //type variable
    | '^' ident //static variable



ident-or-op ::= ident | '(' op_name ')' | '(*)'

op_name ::= symbolic-op | range-op-name | active-pattern-op-name

symbolic-op ::= op_Nil | op_ColonColon | op_Addition | op_Subtraction | op_Multiply //todo: remaining operators

access ::= private | internal | public


